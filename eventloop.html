<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
     
    <!-- Event loop : it's job is to continously monitor the callback and the microtask queue
        and the callstack ... when it found the callstack is empty it will push 
        the callback function from the microtask queue and then from the callback queue
        because the microtask queue has a higher priority compare to callback queue
    -->

    <!-- Microtask queue : All the callback functions which comes through promises 
         will go in the microtask queue ..

         n there is something called mutation observer which checks wether there is
         some mutation in the DOM tree or not ..if there is a mutation in the DOM tree
         it can execute some callback function ..

         so these two things : callback functions comes through Promises and the 
         mutation observer goes inside the callback queue but all the other callback
         functions ..like :
         
         The functions which comes from setTIMEout, DOM APIs, or from the event listners 
         all those goes inside the callback queue 



         ******** Starvation of the task in the callback queue .. when in the microtask 
         queue
         
         if a microtask creates an another microtask in itself in the microtask queue 
         and if it keep on doing the same then the even a single task in the callback
         queue have to wait till all the tasks in microtasks queue completed ..it 
         creates a starvation problem.
    -->

    <!-- BEST QUESIONS ASKED IN THE COMMENTS SECTION -->

    <!-- 
        Amazing content Akshay :-) Have some quick questions: 
        1) When does the event loop actually start ? 
        Are only asynchronous web api callbacks are registered in web api environment ? 
        Does the web api environment stores only the callback function and pushes the same 
        callback to queue/microtask queue? How does it matter if we delay for setTimeout would 
        be 0ms. Then callback will move to queue without any wait ?
     -->

     <!--  ANSWER GIVEN BY AKSHAY SIR -->

     <!-- Wow, these are some of the best doubts. ❤️
1. When does the event loop actually start? - Event loop, as the name suggests, is a single-thread, loop that is `almost infinite`. It's always running and doing its job. ❤️
2.  Are only asynchronous web API callbacks are registered in the web API environment? 
- YES, the synchronous callback functions like what we pass inside map, filter, and reduce 
aren't registered in the Web API environment. It's just those async callback functions that 
go through all this.
3. Does the web API environment stores only the callback function and pushes the same callback 
to queue/microtask queue? - Yes, the callback functions are stored, and a reference is scheduled 
in the queues. Moreover, in the case of event listeners(for example click handlers), the 
original callbacks stay in the web API environment forever, that's why it's advised to explicitly
 remove the listeners when not in use so that the garbage collector does its job.
4. How does it matter if we delay for setTimeout would be 0ms. Then callback will move to 
queue without any wait? 
No, there are trust issues with setTimeout() 😅. The callback function needs to wait until the 
Call Stack is empty. So the 0 ms callback might have to wait for 100ms also if the stack is busy.
It's a very beautiful concept, and I've covered this in detail in the next episode of Namaste 
JavaScript. 🔥
Thank you so much for asking all these questions, Shruti. You're a gem. 💎 -->
</body>
</html>